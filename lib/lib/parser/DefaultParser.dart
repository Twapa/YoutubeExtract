import 'dart:convert';

import 'package:YoutubeExtract/lib/cipher/CachedCipherFactory.dart';
import 'package:YoutubeExtract/lib/cipher/CipherInterface.dart';
import 'package:YoutubeExtract/lib/cipher/decipher.dart';

import 'package:YoutubeExtract/lib/extractor/DefaultExtractor.dart';
import 'package:YoutubeExtract/lib/extractor/Extractor.dart';
import 'package:YoutubeExtract/lib/model/Extensions.dart';
import 'package:YoutubeExtract/lib/model/YouDetails.dart';
import 'package:YoutubeExtract/lib/model/formats/AudioFormat.dart';
import 'package:YoutubeExtract/lib/model/formats/AudioVideoFormat.dart';
import 'package:YoutubeExtract/lib/model/formats/Format.dart';
import 'package:YoutubeExtract/lib/model/formats/VideoFormat.dart';
import 'package:YoutubeExtract/lib/model/itag.dart';
import 'package:YoutubeExtract/lib/model/playlist/PlaylistDetails.dart';
import 'package:YoutubeExtract/lib/model/playlist/PlaylistVideoDetails.dart';
import 'package:YoutubeExtract/lib/model/quality/enums.dart';
import 'package:YoutubeExtract/lib/model/type.dart';
import 'package:YoutubeExtract/lib/parser/Parser.dart';
import 'package:http/http.dart' as http;

class DefaultParser implements Parser {
  // private static final Pattern subtitleLangCodeRegex = Pattern.compile("lang_code=\"(.{2,3})\"");
  RegExp textNumberRegex = RegExp("[0-9, ']+");

  Extractor extractor;
  // CipherFactory cipherFactory;

  DefaultParser() {
    extractor = DefaultExtractor();

    //  this.cipherFactory = new CachedCipherFactory(extractor);
  }

  @override
  Extractor getExtractor() {
    return extractor;
  }

  // @Override
  // public CipherFactory getCipherFactory() {
  //     return cipherFactory;
  // }

  @override
  Future<dynamic> getPlayerConfig(String htmlUrl) async {
    String htmled = await extractor.loadUrl(htmlUrl);
    // print(html);

    //print(html);

    var ytPlayerConfig = extractor.extractYtPlayerConfig(htmled);
    // var uri = Uri.splitQueryString(ytPlayerConfig);
    //var jso = json.decode(uri['args']);

    return ytPlayerConfig;

    // return ind;
  }

  @override
  String getJsUrl(var config) {
    return "https://youtube.com" + config["assets"]["js"];
  }

  @override
  VideoDetails getVideoDetails(var config) {
    var args = config["args"];
    var playerResponse = json.decode(args["player_response"]);

    // if (playerResponse.containsKey("videoDetails")) {

    // }
    var videoDetails = playerResponse["videoDetails"];
    var streamingData = playerResponse['streamingData'];

    String liveHLSUrl = null;

    var isLive = videoDetails['isLive'];

    liveHLSUrl = streamingData['hlsManifestUrl'];

    return new VideoDetails(videoDetails, liveHLSUrl);
  }

  // @Override
  // public List<SubtitlesInfo> getSubtitlesInfoFromCaptions(JSONObject config) {
  //     JSONObject args = config.getJSONObject("args");
  //     JSONObject playerResponse = args.getJSONObject("player_response");

  //     if (!playerResponse.containsKey("captions")) {
  //         return Collections.emptyList();
  //     }
  //     JSONObject captions = playerResponse.getJSONObject("captions");

  //     JSONObject playerCaptionsTracklistRenderer = captions.getJSONObject("playerCaptionsTracklistRenderer");
  //     if (playerCaptionsTracklistRenderer == null || playerCaptionsTracklistRenderer.isEmpty()) {
  //         return Collections.emptyList();
  //     }

  //     JSONArray captionsArray = playerCaptionsTracklistRenderer.getJSONArray("captionTracks");
  //     if (captionsArray == null || captionsArray.isEmpty()) {
  //         return Collections.emptyList();
  //     }

  //     List<SubtitlesInfo> subtitlesInfo = new ArrayList<>();
  //     for (int i = 0; i < captionsArray.size(); i++) {
  //         JSONObject subtitleInfo = captionsArray.getJSONObject(i);
  //         String language = subtitleInfo.getString("languageCode");
  //         String url = subtitleInfo.getString("baseUrl");
  //         String vssId = subtitleInfo.getString("vssId");

  //         if (language != null && url != null && vssId != null) {
  //             boolean isAutoGenerated = vssId.startsWith("a.");
  //             subtitlesInfo.add(new SubtitlesInfo(url, language, isAutoGenerated));
  //         }
  //     }
  //     return subtitlesInfo;
  // }

  // @Override
  // public List<SubtitlesInfo> getSubtitlesInfo(String videoId) throws YoutubeException {
  //     String xmlUrl = "https://video.google.com/timedtext?hl=en&type=list&v=" + videoId;

  //     String subtitlesXml = extractor.loadUrl(xmlUrl);

  //     Matcher matcher = subtitleLangCodeRegex.matcher(subtitlesXml);

  //     if (!matcher.find()) {
  //         return Collections.emptyList();
  //     }

  //     List<SubtitlesInfo> subtitlesInfo = new ArrayList<>();
  //     do {
  //         String language = matcher.group(1);
  //         String url = String.format("https://www.youtube.com/api/timedtext?lang=%s&v=%s",
  //                 language, videoId);
  //         subtitlesInfo.add(new SubtitlesInfo(url, language, false));
  //     } while (matcher.find());

  //     return subtitlesInfo;
  // }

  @override
  Future<List<Format>> parseFormats(var config) async {
    var args = config["args"] ?? null;
    var playerResponse = json.decode(args["player_response"]);

    var streamingData = playerResponse["streamingData"];

    var jsonFormats = [];

    var adaptive = streamingData["adaptiveFormats"];
    jsonFormats.addAll(adaptive);

    var formats = streamingData["formats"] ?? null;
    jsonFormats.addAll(formats);

    List<Format> format = [];

    for (Map<String, dynamic> json in jsonFormats) {
      var parseformat = await parseFormat(json, config);

      format.add(parseformat);
    }

    return format;
  }

  Future<Format> parseFormat(var json, var config) async {
    if (json.containsKey("signatureCipher")) {
      Map<String, dynamic> jsonCipher = {};

      var signatureCipher = json["signatureCipher"];
      var signatureCiphered =
          signatureCipher.replaceAll("\\u0026", "&").split("&") ?? null;

      for (String s in signatureCiphered) {
        var keyValue = s.split('=') ?? null;

        // list[0] is your key and list[1] is your value
        jsonCipher[keyValue[0]] = keyValue[1];
      }

      String urlWithSig = jsonCipher["url"] ?? null;

      String urlsig = utf8.decode(urlWithSig.runes.toList());

      String s = jsonCipher["s"] ?? null;
      s = utf8.decode(s.runes.toList());

      String jsUrl = getJsUrl(config) ?? null;

      http.Client httped = http.Client();

      // Cipher cipher = cipherFactory.createCipher(jsUrl) ?? null;
      // String signature = cipher.getSignature(s);
      // //print(signature);

      // String decipheredUrl = urlWithSig + "&sig=" + signature;

      // json["url"] =decipheredUrl;

      var url = await decipherUrl(jsUrl, signatureCipher, httped);

      // String decipheredUrl = urlWithSig + "&sig=" + signature;

      json['url'] = url.toString();
    }

    // Itag itag;

    int tag = json["itag"];
    type ig = Itag.valueOf(tag);

    bool hasVideo = ig.isVideo();

    bool hasAudio = ig.isAudio();

    //var af = AudioFormat(json);
    //print(af);
    // return null;
    // throw ArgumentError('  unknown itag');

    if (hasVideo && hasAudio)
      return AudioVideoFormat(json);
    else if (hasAudio)
      return AudioFormat(json);
    else if (hasVideo) return VideoFormat(json);
    return null;
    //throw ArgumentError('  unknown itag');
  }

//playlist
  ////////////////////////////////////////////////////////////////////////////////////////////
  ///
  ///
  ///

  @override
  getInitialData(String htmlUrl) async {
    String html = await extractor.loadUrl(htmlUrl);

    String ytInitialData = extractor.extractYtInitialData(html);
    // print(json.decode(json.decode(ytInitialData)));

    return json.decode(ytInitialData);
  }

  @override
  getPlaylistDetails(String playlistId, var initialData) {
    String title = initialData["metadata"]["playlistMetadataRenderer"]["title"];

    var sideBarItems =
        initialData["sidebar"]["playlistSidebarRenderer"]["items"];

    String author = sideBarItems[1]["playlistSidebarSecondaryInfoRenderer"]
        ["videoOwner"]["videoOwnerRenderer"]["title"]["runs"][0]["text"];

    var stats = sideBarItems[0]["playlistSidebarPrimaryInfoRenderer"]["stats"];

    var videoCount = extractNumber(stats[0]["runs"][0]["text"]);

    //var viewCount = extractNumber(stats[1]["simpleText"]);

    return new PlaylistDetails(playlistId, title, author, videoCount);
  }

  @override
  getPlaylistVideos(var initialData, var videoCount) {
    int videoc = int.parse(videoCount);
    var content = initialData["contents"]["twoColumnBrowseResultsRenderer"]
                ["tabs"][0]["tabRenderer"]["content"]["sectionListRenderer"]
            ["contents"][0]["itemSectionRenderer"]["contents"][0]
        ["playlistVideoListRenderer"];

    List<PlaylistVideoDetails> videos =[];
    //if (videoc > 0) {
    //  videos = List(videoc);
    // } else {
    //  videos = [];
    // }

    populatePlaylist(content, videos, getClientVersion(initialData));
    
     return videos;
  }

  populatePlaylist(
      var content, List<PlaylistVideoDetails> videos, String clientVersion) {
    List contents = content["contents"];

    for (int i = 0; i < contents.length; i++) {
      videos.add(PlaylistVideoDetails(contents[i]["playlistVideoRenderer"]));
    }

    // if (content.containsKey("continuations")) {
    //   String continuation =
    //       content["continuations"][0]["nextContinuationData"]["continuation"];
    //   //loadPlaylistContinuation(continuation, videos, clientVersion);
    // }
  }

  loadPlaylistContinuation(String continuation,
      List<PlaylistVideoDetails> videos, String clientVersion) async {
    var content;

    String url = "https://www.youtube.com/browse_ajax?ctoken=" +
        continuation +
        "&continuation=" +
        continuation;

    getExtractor().setRequestProperty("X-YouTube-Client-Name", "1");
    getExtractor()
        .setRequestProperty("X-YouTube-Client-Version", clientVersion);
    String html = await getExtractor().loadUrl(url);

    try {
      var response = json.decode(html);
      content = response[1]["response"]["continuationContents"]
          ["playlistVideoListContinuation"];
      populatePlaylist(content, videos, clientVersion);
    } catch (e) {
      throw e;
    } catch (e) {
      throw ("Could not parse playlist continuation json");
    }
  }

  String getClientVersion(var json) {
    var trackingParams = json["responseContext"]["serviceTrackingParams"];
    if (trackingParams == null) {
      return "2.20200720.00.02";
    }
    for (int ti = 0; ti < trackingParams.length; ti++) {
      var params = trackingParams[ti]["params"];
      for (int pi = 0; pi < params.length; pi++) {
        if (params[pi]["key"] == "cver") {
          return params[pi]["value"];
        }
      }
    }
    return null;
  }

  extractNumber(String text) {
    var matcher =
        textNumberRegex.firstMatch(text).group(0).replaceAll("[, ']", "");

    return matcher;
  }
}
